/*
* WireX  -  WireLib
*
* Copyright (c) 2006-2019 Andreas Pott
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

/*! \file RobotData.h
 *
 *	\author   Andreas Pott
 *
 *  \dependency
 *		Eigen3		for IR³ algebra
 *		tinyXML		for parameter IO
 *
 *  \brief
 *  Implementation of data strcture for cable-driven parallel robots. This 
 *  structure is a redesign of the original version of WireLib. 
 */

#pragma once

#include <string>
#include "EigenLib.h"
#include <vector>
#include <tinyXML/tinyxml.h>
#include "TechKB.h"

namespace PCRL {

/*! \class CWinchParameter
 *  This class stores mostly technical parameters about the winches such as
 *  maximum torque of the motor and gear ration. Furthermore, dependencies 
 *  between the parameters can be implemented.
 */
class CWinchParameter
{
public:
	string name;		//!< a unique name for a special winch or (more likely) for the archetype of a type series
	string description; //!< winch description
	// cable-related quantities
	int nr_cables;		//!< number of cables wound on the winch
	double transmission_ratio; //!< transmission ratio of motor turns to cable length
	double f_max;		//!< maximum force [N] of the cable (derived from the torque generated by the motor)
	double f_hold_max;	//!< part of XML specification may be unecessary for WireCenter!
	double string_orientation; //!< part of XML specification may be unecessary for WireCenter! (Should be a string?!)
	double dl_max;		//!< maximum length of the cable that can be wound up onto the drum [m]
	double l0;			//!< free length of the cable when cable is fully wound up onto the drum [m]
	double v;			//!< maximum velocity [m/s] of the cable
	double a;			//!< maximum acceleration [m/s²] of the cable
	double j;			//!< maximum jerk [m/s³] of the cable
	double position_sensor_accuracy;	//!< the resulution of the position measurement system
	double force_sensor_accuracy;		//!< the resulution of the force sensor
	double spring_constant; //!< Spring constant of the winch
	double length_offset;   //!< length offset
	// motor-related quantities
	string motor_type;	//!< description of the motor type used
	double M_motor;		//!< maximum torque [Nm] generated by the motor
	double alpha_motor;	//!< maximum angular acceleration [rad/s²] of the motor
	double omega_motor;	//!< maximum angular velocity [rad/s] of the motor 
	//double ratio;		//!< gear ratio (values >1 reduce the velocity of the cable)
	double inertia;				//!< motor inertia, part of XML specification may be unecessary for WireCenter!
	double mass;				//!< part of XML specification may be unecessary for WireCenter!
	double max_power;			//!< part of XML specification may be unecessary for WireCenter!
	//double angular_velocity;	//!< part of XML specification may be unecessary for WireCenter!
	//double angular_acceleration;//!< part of XML specification may be unecessary for WireCenter!
	double gear_ratio;			//!< part of XML specification may be unecessary for WireCenter!
	// drum-related quantities
	double r_drum;		//!< radius of the drum in the winch [m]
	double n_drum;		//!< maximum number of windings on the drum
	double l_drum;		//!< axial length of the drum [m]
	double nr_groove;		//!< part of XML specification may be unecessary for WireCenter!
	double groove_depth;	//!< part of XML specification may be unecessary for WireCenter!
	double dfriction;		//!< part of XML specification may be unecessary for WireCenter!
	double sfriction;		//!< part of XML specification may be unecessary for WireCenter!
	double backlash;		//!< part of XML specification may be unecessary for WireCenter!
	int spool_direction; //!< not part of XML spec, is either 1 (spool traverse increases effective radius), -1 (spool traverse decreases), 0 (no spool traverse)
	// guidinglimit related quantities
	double aperture;	//!< the aperture angle of the cable from the center of the cone
	double cone_offset; //!< the aperture offset from winch position a
	// anchoring related Attributes
	string anchoring_type;
	double max_force;
	Vector3d acting_moment; //acting moment defined from winch position a
	
public:
	CWinchParameter()
	{
		name = "IPAnema-Winde";
		description = "Winde des IPAnema roboters ausgelegt fuer 2,5mm und 6mm Dyneema Seil";

		// cable-related quantities
		nr_cables = 1;		
		transmission_ratio = 0; 
		f_max = 720;		
		f_hold_max = 0;	
		string_orientation = 0;
		dl_max = 0;
		l0 = 0;		
		v = 2.618;		
		a = 0;	
		j = 0;
		position_sensor_accuracy = 0;
		force_sensor_accuracy = 0;	
		spring_constant = 0; 
		length_offset = 0;   
		
		// motor-related quantities
		motor_type = "Bosch Rexroth MSK050B-0600-NN-M2-UG1-RNNN";	
		M_motor = 3;	
		alpha_motor = 0;
		omega_motor = 6000;
		//ratio = 12;		
		inertia = 0.001527;	
		mass = 5.7;		
		max_power = 0;
		gear_ratio = 3;
		
		// drum-related quantities
		r_drum = 0.1;		
		n_drum = 15;		
		l_drum = 0.3;		
		nr_groove = 14;		
		groove_depth = 0.003;	
		dfriction = 0;		
		sfriction = 0;		
		backlash = 0;		
		spool_direction = 1;

		// guidinglimit related quantities
		aperture = 180*DEG_TO_RAD;		
		cone_offset = 0;

		// anchoring related Attributes
		anchoring_type = "defaultAnchoring";
		max_force = 0;
		acting_moment = Vector3d(0,0,0);
	}

public:
	//! write the class data into an xml node
	bool setXmlNode(TiXmlElement* parent) const;
	//! read the attributes from the xml node
    bool getXmlNode(TiXmlElement* winch);
	//! could rename to  bool getXmlNode(TiXmlElement* parent);
	bool loadXML(TiXmlElement* parent,int id);    
	//! gets filename to save to
	bool saveXML(const string& filename); 

	//! set name for a special winch or an archetype of a type series
	void setName(const std::string &name){this->name = name;}
	//! set maximum force [N] of the cable (derived from the torque generated by the motor)
	void setCable_MaxForce(const double &f_max){this->f_max = f_max;}
	//! set maximum length of the cable that can be wound onto the drum [m]
	void setCable_MaxLenghtInDrum(const double &dl_max){this->dl_max = dl_max;}
	//! set free length of the cable when it is fully wound onto the drum [m]
	void setCable_l0(const double &l0){this->l0 = l0;}
	//! set maximum velocity [m/s] of the cable
	void setCable_MaxVelocity(const double &v){this->v = v;}
	//! set maximum acceleration [m/s²] of the cable
	void setCable_MaxAcceleration(const double &a){this->a = a;}
	//! set the resolution of the position measurement system
	void setPositionSensor_Accuracy(const double &position_sensor_accuracy){this->position_sensor_accuracy = position_sensor_accuracy;}
	//! set the resolution of the force sensor
	void setForceSensor_Accuracy(const double &force_sensor_accuracy){this->force_sensor_accuracy = force_sensor_accuracy;}
	//! set maximum torque [Nm] generated by the motor
	void setMotor_MaxTorque(const double &M_motor){this->M_motor = M_motor;}
	//! set maximum angular acceleration [rad/s²] of the motor
	void setMotor_MaxAcceleration(const double &alpha_motor){this->alpha_motor = alpha_motor;}
	//! set maximum angular velocity [rad/s] of the motor 
	void setMotor_MaxVelocity(const double &omega_motor){this->omega_motor = omega_motor;}
	//! set gear ratio (values >1 reduce the velocity of the cable)
	void setMotor_GearRatio(const double &gear_ratio){this->gear_ratio = gear_ratio;}
	//! set inertia with respect to the motor [kg m²]
	void setMotor_Inertia(const double &inertia){this->inertia = inertia;}
	//! set radius of the drum in the winch [m]
	void setDrum_Radius(const double &r_drum){this->r_drum = r_drum;}
	//! set maximum number of windings on the drum
	void setDrum_MaxWindings(const double &n_drum){this->n_drum = n_drum;}
	//! set axial length of the drum [m]
	void setDrum_Length(const double &l_drum){this->l_drum = l_drum;}
	//! set the aperture angle of the cable from the center of the cone
	void setPulley_Aperture(const double &aperture){this->aperture = aperture;}

	//! get name of a winch or an archetype of a type series
	std::string getName()const{return this->name;}
	//! get maximum force [N] of the cable (derived from the torque generated by the motor)
	double  getCable_MaxForce()const{return this->f_max;}
	//! get maximum length of the cable that can be wound onto the drum [m]
	double  getCable_MaxLenghtInDrum()const{return this->dl_max;}
	//! get free length of the cable when it is fully wound onto the drum [m]
	double  getCable_l0()const{return this->l0;}
	//! get maximum velocity [m/s] of the cable
	double  getCable_MaxVelocity()const{return this->v;}
	//! get maximum acceleration [m/s²] of the cable
	double  getCable_MaxAcceleration()const{return this->a;}
	//! get the resolution of the position measurement system
	double  getPositionSensor_Accuracy()const{return this->position_sensor_accuracy;}
	//! get the resolution of the force sensor
	double  getForceSensor_Accuracy()const{return this->force_sensor_accuracy;}
	//! get maximum torque [Nm] generated by the motor
	double  getMotor_MaxTorque()const{return this->M_motor;}
	//! get maximum angular acceleration [rad/s²] of the motor
	double  getMotor_MaxAcceleration()const{return this->alpha_motor;}
	//! get maximum angular velocity [rad/s] of the motor 
	double  getMotor_MaxVelocity()const{return this->omega_motor;}
	//! get gear ratio (values >1 reduce the velocity of the cable)
	double  getMotor_GearRatio()const{return this->gear_ratio;}
	//! get inertia with respect to the motor [kg m²]
	double getMotor_Inertia()const{return this->inertia;}
	//! get radius of the drum in the winch [m]
	double  getDrum_Radius()const{return this->r_drum;}
	//! get maximum number of windings on the drum
	double  getDrum_MaxWindings(){return this->n_drum;}
	//! get axial length of the drum [m]
	double  getDrum_Length()const{return this->l_drum;}
	//! get the aperture angle of the cable from the center of the cone
	double  getPulley_Aperture()const{return this->aperture;}
	//! get the equivalent mass in kg of the rotating parts of the winch
	double  getWinch_EquivalentMass();
	//! get the effective radius of the winch (including spool traverse)
	double  getWinch_EffectiveRadius();

};

/*! \class CCableParameter
 *  This classes collects the characteristic parameter of a cable.
 */
class CCableParameter
{
public:
	string name;		//!< a unique name for the cable type
	// maybe k_spec should be used instead of E_wire
	double E_wire;		//!< Young modulus of the cable material [N/m²] (be careful with the units: here we go for SI units, where N/mm² is often used in the literature)
	double r_cable;		//!< radius of the cable [m]
	double F_breakingload;	//!< maximum feasible load of the cable before it breaks down [N]
	double minimum_load; //!< minimum feasible load on the cable [N]
	double max_length;	//!< maximum cable length in [m]
	double damping;		//!< specific damping constant (as damping per length)
	double k_spec;		//!< specific spring constant [N]   (current cable stiffness: k = k_spec/l)
	double weight;		//!< specific weight per length (kg/m)
	Vector3d* pConstraints;	//!< additional constraints for each cable (additional to b_i, a_i)
	int nContraints;	//!< number of additional constraints
	double meter_cost;	//!< cost per meter (€/m)
	string material;	//!< material

	CCableParameter()
	{
		name = "defaultCable";
		r_cable =0.006;			//! typical diameter of Dyneema cable
		E_wire = 110000e6;		//!< steel cable as given Klaus Feyrer, "Drahtseile - Bemessung, Betrieb, Sicherheit", 2. Auflage, Springer Verlag Wien 2000, p.92-94; dyneema should be in the same range
		F_breakingload = 40000;	//!< breaking load of 6mm dynnema cable
		damping = 1;			//!< we have no number here
		k_spec = 10000;			//!< specific spring constant
		weight = 0.023;			//!< typical weight per meter of dyneema cable with diameter of 6mm [kg/m]
		minimum_load =0;
		max_length =0;
		pConstraints = 0;
		nContraints = 0;		//!< no additional constraints in the default case
		meter_cost = 0;
		material = "defaultMaterial";
	}

	~CCableParameter()
	{
		if (pConstraints)
		delete [] pConstraints;
	}

public:
	//! write the class data into an xml node
	bool setXmlNode(TiXmlElement* parent) const;
	bool loadXML(TiXmlElement* parent,int id);
	bool saveXML(const string& filename);

	//! define the unique name for the cable type
	bool setname(const string& name);
	//! define the young modulus of the cable material [N/m²] 
	bool setE_wire(const double& E_wire);
	//! define the radius of the cable [m]
	bool setr_cable(const double& r_cable);
	//! define the maximum feasible load of the cable before it breaks down
	bool setF_breakingload(const double& F_breakingload);
	//! define the specific damping constant (as damping per length)
	bool setdamping(const double& damping);
	//! define the specific weight per length (kg/m)
	bool setweight(const double& weight);

	//! get the unique name for the cable type
	const string& getname(){return this->name;}
	//! get the young modulus of the cable material [N/m²] 
	double getE_wire() const {return this->E_wire;}
	//! get the radius of the cable [m]
	double getr_cable() const {return this->r_cable;}
	//! get the maximum feasible load of the cable before it breaks down
	double getF_breakingload() const {return this->F_breakingload;}
	//! get the specific damping constant (as damping per length)
	double getdamping() const {return this->damping;}
	//! get the specific weight per length (kg/m)
	double getweight() const {return this->weight;}

};

/*! \class CRobotData
 *  This class represents the geometry and technological data of a cable-driven 
 *  parallel robot.
 *  The class collects the major geometric (Ai, Bi, RAi, RBi) and technologic 
 *  parameters such as number of cables, inertia of platform and base, 
 *  limits on cable length and limits on cable force.
 *  Furthermore, the basic model level is defined through the motion pattern 
 *  as well as the settings on the applied model level (with/without pulleys,
 *  static/elastic, massless/hefty cables). These settings represent hints
 *  for the algorithms to decide which computations need to be undertaken. 
 *  CRobotData itself maintains consistence of the robot description as well as
 *  manangement of the data stored without performing actual analysis on the 
 *  robots.
 */
class CRobotData
{
	friend class CKinematics;
public:
	//! the motion pattern defines which kind of motion of the platform is considered
	//! note that different motion pattern for the identical geometry may significantly
	//! change the behaviour of the robot. 
	typedef enum {MP1T=1, MP2T=2, MP3T=4, MP1R2T=8, MP2R3T=16, MP3R3T=32} MotionPatternType;
	//! kinematics model of the winches. FIXED reflects a point-shaped (ideal) guiding of 
	//! of the cables where length and deflection angle are decoupled. For PULLEY there
	//! is a connection between the direction of the cable and its length. 
	typedef enum {FIXED, PULLEY} RobotKinematicsType;
	//! the elastic model applied to both shape of the cable and its rigidity. NONELASTIC
	//! means perfectly stiff, linear elastic accounts for elastic elongation of the 
	//! cable. SAGGING modells hefty cables, i.e. cables having a finite mass leading
	//! to deformations due to its own weight.
	typedef enum {NONELASTIC, LIN_ELASTIC, SAGGING} ElasticityModelType;
protected:
	int dof;								//!< degree-of-freedom; note that the degrees-of-freedom depend on the motion pattern
	int now;								//!< number of wires
	//!< The general structure of the cable robot can be defined using the following 
	MotionPatternType motionPattern;		//!< indicate the motion pattern of the current robot where for fully parallel cable robots only six different types exist
	RobotKinematicsType robotKinematicsModel;	//!< indicate the used kinematics model 
	ElasticityModelType elasticityModel;	//!< indicate the used kinematics model 

	Vector3d* base;					//!< pivot points on the base
	Vector3d* platform;				//!< pivot points on the platform
	Matrix3d* R_base;				//!< the orientation of the base frame; the orientation is important e.g. for pulley mechanisms
	Matrix3d* R_platform;			//!< the orientation of the base platform anchor points; the orientation is important e.g. when using universal joints to connect the cables
	
public:
	double* r_pulley;				//!< the radius of the pulley wheel ***!!may be property of pulley mechanism!!***

	CCableParameter* pCable;	//!<pointer to an array of cable objects
	CWinchParameter* pWinch;	//!<pointer to an array of winch objects
	double lmin,lmax;			//!< minimal and maximal length of the wires [m]; the values specifies what we allow for this robot where the capacity of the winches may be different
	double fmin,fmax;			//!< minimal and maximal feasible force of the wires [N]; the values specifies what we allow for this robot where the capacity of the winches may be different

	string platform_name; //!< name of platform
	string platform_desc; //!< description of platform

	double platform_mass; //!< mass of the platform; this value does not meat that force is exerted on the platform during simulations (VLS at the moment 22.09.2011)
	double platform_swingangle; //!< swing angle of wires
	Matrix3d platform_inertia;	//!< inertia tensor to represent platform inertia
	Vector3d centerofgravity; //!< vector within platform frame indicating the center of gravity of the platform

	double controller_ipotakt; //!< ipo clock cycle time

/*	string application_name; //!< name of application for robot
	int application_id; //!< unique identifier for application 
	string application_desc; //!< description of application
	double application_load_mass; //!< load mass of application
	double application_load_moment; //!< moments of application
	double application_min_cableload; //!< minimum load for cables as defined by application
	double application_max_cableload; //!< maximum load for cables as defined by application
*/
public:
	explicit CRobotData(const unsigned int& numberOfWires=7, const MotionPatternType mp=MP3R3T);
	virtual ~CRobotData(void);
private:
	CRobotData(const CRobotData& src) { assert(false); }
public:
	
	//! copy operator
	CRobotData& operator=(const CRobotData& src);

	//! define the geometry of platform and base for one leg
	void setLeg(const int& id, const Vector3d& b, const Vector3d& p);
	//! get the geometry of platform and base for one leg
	void getLeg(const int& id, Vector3d& b, Vector3d& p);
	//! get the geometry of the platform and base as matrix [a_1, b_1 | ... | a_m, b_m]
	void getLegMatrix(MatrixXd& AB);
	//! define the geometry of base for one leg
	void setBase(const int& id, const Vector3d& b);
	//! define the orientation of the base for one leg
	void setBaseOrientation(const int& id, const Matrix3d& R);
	//! define the geometry of platform for one leg
	void setPlatform(const int& id, const Vector3d& p);
	//! define the allowed minimum and maximum forces for the wires
	void setForceLimits(const double& Fmin, const double& Fmax) {fmin=Fmin; fmax=Fmax; }
	//! set new values for degree-of-freedom and number of wires; existing geometry is deleted
	void setMotionPattern(const int& numberOfWires=7, const MotionPatternType mp=MP3R3T);
	//! set new values for degree-of-freedom and number of wires; existing geometry is deleted
	MotionPatternType getMotionPattern() { return motionPattern; }
	//! set type of kinematic model
	void setRobotKinematicsModel(const RobotKinematicsType rk){robotKinematicsModel= rk;}
	//! get type of kinemtic model
	RobotKinematicsType getRobotKinematicsModel(){ return robotKinematicsModel;}
	//! set type of elasticity model
	void setElasticityModel(const ElasticityModelType em){elasticityModel = em;}
	//! get type of elasticity model
	ElasticityModelType getElasticityModel(){ return elasticityModel;}
	//! set maximum and minimum wire length
	void setWireLength(const double& Lmin, const double& Lmax) {lmin=Lmin; lmax=Lmax; }
	//! set the radius of the pulley
    void setPulleyRadius(const double &radius) {
        for ( unsigned int iPulley = 0 ; iPulley < (unsigned int) getNow(); iPulley++ ) {
            r_pulley[iPulley] = radius;
        }
    }
	void setPulleyRadius(const double& radius, int i) { r_pulley[i] = radius; }
	//! read the geometry of one leg's platform
	const Vector3d& getPlatform(const int& id) { return platform[id]; }
	//! get the geometry of the platform as matrix [b_1, ...,b_m]
	MatrixXd getPlatformMatrix();
	//! read the geometry of one leg's base
	const Vector3d& getBase(const int& id) { return base[id]; }
	//! get the geometry of the base as matrix [a_1, ..., a_m]
	MatrixXd getBaseMatrix();
	//! get the orientation of the base for one leg
	const Matrix3d& getBaseOrientation(const int& id)const{return R_base[id];}
	//! get the degree-of-freedom of the mobile platform
	int getDof() const { return dof; }
	//! get the number of wires for the robot
	int getNow() const { return now; }
	//! calculate an axis-aligned bounding box for the frame/base
	bool getBoundingBoxBase(Vector3d& bbmin, Vector3d &bbmax);
	//! calculate an axis-aligned bounding box for the platform
	bool getBoundingBoxPlatform(Vector3d& bbmin, Vector3d &bbmax);
	//! return the mid point of the base's bounding box
	Vector3d getBoundingBoxCenterBase();
	//! return the mid point of the platforms's bounding box
	Vector3d getBoundingBoxCenterPlatform();
	//! set the base anchor points to a cubic geometry
	bool setFrameGeometryCube(const double length, const double width, const double height);
	//! set the platform anchor points to a cubic geometry
	bool setPlatformGeometryCube(const double length, const double width, const double height); 
	//! translate all frame geometry vectors by an offset
	bool translateFrameGeometry(const Vector3d& dr);
	//! rotate all frame geometry vectors by a rotation matrix 
	bool rotateFrameGeoemetry(const Matrix3d& dR);
	//! scale all frame geometry vectors by values in the vector s
	bool scaleFrameGeometry(const Vector3d& s);
	//! scale the frame such that its bounding box equals the given volumen
	bool normalizeFrameGeometry(const double& volume=1);

	//! translate all frame geometry vectors by an offset
	bool translatePlatformGeometry(const Vector3d& dr);
	//! rotate all frame geometry vectors by a rotation matrix 
	bool rotatePlatformGeoemetry(const Matrix3d& dR);
	//! scale all frame geometry vectors by values in the vector s
	bool scalePlatformGeometry(const Vector3d& s);

	bool SetNow(const int now);
	//! load robot parameter for text file
	bool Load(const string& filename);
	//! save robot parameter to a text file
	bool Save(const string& filename);
	//! load robot parameter from XML file
	bool loadXml(const string& filename);
	//! save robot parameter into an XML file; this is a new implementation
	bool saveXmlAtlas(const string& filename);
	//! set the sub-nodes and attributes for the <robot> node
	bool setXmlNode(TiXmlElement& robot);
	//! get the sub-nodes and attributes from the <robot> node
	bool getXmlNode(TiXmlElement& robot);

	//// experimental 
	//! access a geometric parameter of the robot by a pure id
	double& getByID(const int& id);
};

}	// end of namespace PCRL